## Overview of Built-In Sequences
### Container Sequences
- can hold items of different types, including nested containers
- examples: `list`, `tuple`, and `collections.deque`
- holds references to the object it contains which may be of any type
### Flat Sequences
- hold items of one simple type
- examples: `str`, `bytes`, and `array.array`
- stores the value of its contents in its own memory space, not as distinct Python objects
- more compact but limited to holding primitive machine values like bytes, integers, and floats
### Mutable Sequences
- examples: `list`, `bytearray`, `array.array`, and `collections.deque`
- inherit all methods from immutable sequences, and implement several additional methods
### Immutable Sequences
- examples: `tuple`, `str`, and `bytes`

![[Screenshot 2025-07-20 at 1.57.23 PM.png]]
- All mutable sequences implement the methods of immutable sequences, plus methods like `append`, `insert`, `pop`, etc.
- The built-in concrete sequence types do not actually subclass the Sequence and MutableSequence ABCs.
	- The built-in classes like `list` and `tuple` **do not literally inherit** from `collections.abc.Sequence` or `MutableSequence` in their class definitions.
	- Still, they behave _as if_ they are subclasses because they are **registered as virtual subclasses** of those ABCs
- In Python, a class can be _registered_ as a virtual subclass of an ABC without actually subclassing it.
- It means you can write generic code that works on _any_ sequence—built-in or custom—by checking against `collections.abc.Sequence`, and Python will treat virtual subclasses correctly.

Keep in mind these common traits: mutable versus immutable; container versus flat. They are helpful to extrapolate what you know about one sequence type to others.

## List Comprehensions and Generator Expressions
### Local Scope Within Comprehensions and Generator Expressions
- list comprehensions, generator expressions, and their siblings `set` and `dict` comprehensions have a local scope to hold the variables assigned int eh `for` clause
- BUT variables assigned with the "Walrus operator" `:=` remain accessible after those comprehensions or expressions return, unlike local variables in a function
### Listcomps Versus `map` and `filter`
- listcomps do everything the `map` and `filter` functions do, without the contortions of the functionally challenged Python `lambda`

**Listcomps are a one-trick pony: they build lists. To generate data for other sequence types, a genexp is the way to go**
### Generator Expressions
- genexp saves memory because it yields items one by one using the iterator protocol instead of building a whole list just to feed another constructor
- use the same syntax as listcomps, but are enclosed in parentheses rather than brackets
- A **generator expression** is similar to a **list comprehension**, but instead of building a full list in memory, it produces **items one by one** using the **iterator protocol**.
	- It saves memory
	- It is lazy: items are only produced **when needed**

| Feature      | List Comprehension                    | Generator Expression                  |
| ------------ | ------------------------------------- | ------------------------------------- |
| Syntax       | `[... for ... in ...]`                | `(... for ... in ...)`                |
| Returns      | A full list in memory                 | A generator (lazy iterator)           |
| Memory usage | High (stores all results)             | Low (produces values one at a time)   |
| Best for     | When you need to reuse all the values | When looping once, or memory is tight |
## Tuples Are Not Just Immutable Lists
- Tuples do double duty: can be used as immutable lists and also as records with no field names

### Tuples as Records
- each item in the tuple holds the data for one field, and the position of the item gives its meaning
- tuple unpacking: the process of assigning each value in a tuple (or iterable) to a separate variable in a single statement

|Concept|Explanation|
|---|---|
|**Tuples as records**|Used to group related data (like a row in a table).|
|**Unpacking**|Assign each value from a tuple to a separate variable.|
|**Dummy variable `_`**|Used when you want to ignore a value.|
|**String formatting with tuples**|`%s/%s` expects a 2-element tuple; each `%s` grabs one item.|
|**Sorting tuples**|`sorted()` sorts by the first item in each tuple by default.|
### Tuples as Immutable Lists
- Clarity: when you see a `tuple` in code, you know its length will never change
- Performance: a `tuple` uses less memory than a `list` of the same length, and it allows Python to do some optimizations

**Are tuples more efficient that lists in Python:**
- To evaluate a tuple literal, the Python compiler generates bytecode for a tuple constant in one operation; but for a list literal, the generated bytecode pushes each element as a separate constant to the data stack, and then builds the list.
- Given a tuple `t`, `tuple(t)` simply returns a reference to the same `t`. There’s no need to copy. In contrast, given a list `l`, the `list(l)` constructor must create a new copy of `l`.
- Because of its fixed length, a `tuple` instance is allocated the exact memory space it needs. Instances of `list`, on the other hand, are allocated with room to spare, to amortize the cost of future appends.
- The references to the items in a tuple are stored in an array in the tuple struct, while a list holds a pointer to an array of references stored elsewhere. The indirection is necessary because when a list grows beyond the space currently allocated, Python needs to reallocate the array of references to make room. The extra indirection makes CPU caches less effective.
### Comparing Tuple and List Methods
| Method / Attribute           | list | tuple | Description                                                                 |
|-----------------------------|:----:|:-----:|-----------------------------------------------------------------------------|
| `s.__add__(s2)`             |  ✅  |  ✅   | `s + s2` — concatenation                                                    |
| `s.__iadd__(s2)`            |  ✅  |       | `s += s2` — in-place concatenation                                          |
| `s.append(e)`               |  ✅  |       | Append one element at the end                                               |
| `s.clear()`                 |  ✅  |       | Delete all items                                                            |
| `s.__contains__(e)`         |  ✅  |  ✅   | `e in s` — membership test                                                  |
| `s.copy()`                  |  ✅  |       | Shallow copy of the list                                                    |
| `s.count(e)`                |  ✅  |  ✅   | Count occurrences of element `e`                                            |
| `s.__delitem__(p)`          |  ✅  |       | Delete item at position `p`                                                 |
| `s.extend(it)`              |  ✅  |       | Append items from iterable `it`                                             |
| `s.__getitem__(p)`          |  ✅  |  ✅   | `s[p]` — get item at position                                               |
| `s.__getnewargs__()`        |       |  ✅   | Support for optimized serialization with `pickle`                           |
| `s.index(e)`                |  ✅  |  ✅   | Find position of first occurrence of `e`                                    |
| `s.insert(p, e)`            |  ✅  |       | Insert element `e` before position `p`                                      |
| `s.__iter__()`              |  ✅  |  ✅   | Get iterator                                                                |
| `s.__len__()`               |  ✅  |  ✅   | `len(s)` — number of items                                                  |
| `s.__mul__(n)`              |  ✅  |  ✅   | `s * n` — repeated concatenation                                            |
| `s.__imul__(n)`             |  ✅  |       | `s *= n` — in-place repeated concatenation                                  |
| `s.__rmul__(n)`             |  ✅  |  ✅   | `n * s` — reverse repeated concatenation                                    |
| `s.pop([p])`                |  ✅  |       | Remove and return last item or item at position `p`                         |
| `s.remove(e)`               |  ✅  |       | Remove first occurrence of `e` by value                                     |
| `s.reverse()`               |  ✅  |       | Reverse the list in place                                                   |
| `s.__reversed__()`          |  ✅  |       | Get iterator to scan items from last to first                               |
| `s.__setitem__(p, e)`       |  ✅  |       | `s[p] = e` — overwrite item at position `p`                                 |
| `s.sort([key], [reverse])`  |  ✅  |       | Sort list in place with optional `key` and `reverse` arguments              |
## Unpacking Sequences and Iterables
- Unpacking is important because it avoids unnecessary and error-prone use of indexes to extract elements from sequences
- Parallel assignment: assigning items from an iterable to a tuple of variables
- using `*`
```python
>>> t = (20, 8)
>>> divmod(*t)
(2, 4)

quotient, remainder = divmod(*t)
```

|Unpacking Pattern|Purpose|
|---|---|
|`divmod(*t)`|Unpack arguments when calling a function|
|`a, b = divmod(...)`|Unpack function return value|
|`_, filename = os.path.split(path)`|Discard part of the return tuple|
|`a, *body, c = seq`|Capture a variable-length "middle" part of data|
### Using * to Grab Excess Items
```python
>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])

>>> a, b, *rest = range(3)
>>> a, b, rest
(0, 1, [2])

>>> a, b, *rest = range(2)
>>> a, b, rest
(0, 1, [])
```

### Unpacking with * in Function Calls and Sequence Literals
- `*` unpacks any iterable (like lists, tuples, ranges)
- it spreads the elements out where multiple values are expected—either in a function call or inside a literal like a list, tuple, or set

In function calls:
```python
>>> def fun(a, b, c, d, *rest):
	    return a, b, c, d, rest

>>> fun(*[1, 2], 3, *range(4, 7))

(1, 2, 3, 4, (5, 6))
```

In defining `list`, `tuple`, or `set` literals
```python
>>> *range(4), 4
(0, 1, 2, 3, 4)

>>> [*range(4), 4]
[0, 1, 2, 3, 4]

>>> {*range(4), 4, *(5, 6, 7)}
{0, 1, 2, 3, 4, 5, 6, 7}
```

### Nested Unpacking
- when you unpack elements from a nested (multi-level) data structure like a tuple, list, or combination of both—in a single assignment—by matching its shape
- cleans up code by avoiding multiple indexing steps
- can access inner values directly in loops or assignments

## Pattern Matching with Sequences
```python
def handle_command(self, message):
	match message:
		case ['BEEPER', frequency, times]:
			self.beep(times, frequency)
		case ['NECK', angle]:
			self.rotate_neck(angle)
		case ['LED', ident, intensity]:
			self.leds[ident].set_brightness(ident, intensity)
		case ['LED', ident, red, green, blue]:
			self.leds[ident].set_color(ident, red, green, blue)
		case _:
			raise InvalidCommand(message)
```

Destructuring
- a more advanced form of unpacking
- new word in Python vocab

In general, a sequence pattern matches the subject if:
1. The subject is a sequence and;
2. The subject and the pattern have the same number of items and;
3. Each corresponding item matches, including nested items

A sequence pattern is something like this:
```python
case [a, b, c]:
```

This will only match objects that behave like sequences — meaning they implement the `collections.abc.Sequence` interface (like `list`, `tuple`, etc.).

✅ These are valid:
- `list`
- `tuple`
- `range`
- `collections.deque`
- `memoryview`
- `array.array`

❌ But these are exceptions:
- `str`
- `bytes`
- `bytearray`

Destructuring only works on sequences
- Unlike regular unpacking (`a, b = something`), `match/case` won’t work on general **iterables** like generators or iterators — only **actual sequences**.

`_` in patterns
- matches any single item in that position but is never bound to the value of the matched item
- can appear more than once in a pattern

Type information in patterns
```python
case [str(name), _, _, (float(lat), float(lon))]:

case [str(name), *_, (float(lat), float(lon))]:
```

### Pattern Matching Sequences in an Interpreter
| Feature         | Pre-3.10                 | Pattern Matching                |
| --------------- | ------------------------ | ------------------------------- |
| Pattern check   | Manual (`exp[0] == 'x'`) | Declarative (`case ['x', ...]`) |
| Unpacking       | Separate line            | Built-in                        |
| Type guards     | Manual (`isinstance`)    | Built-in (`Symbol() as name`)   |
| Nested patterns | Verbose                  | Clean and supported             |
| Catch-all       | Manual (`else:`)         | `case _:`                       |
| Readability     | Moderate                 | High                            |
| Error handling  | Easy to skip             | Encouraged                      |

#### Alternative patterns for lambda 
```python
>>> (lambda (x y z) body1 body2 ...)
>>> case ['lambda', parms, *body] if body:
['lambda', 'x', ['*', 'x', 2]]

>>> case ['lambda', [*parms], *body] if body: # should be matched this way
['lambda', ['x', 'y'], ['+', 'x', 'y']]
```

#### Shortcut syntax for function definition
*too lazy to do this part

## Slicing
### Why Slices and Ranges Exclude the Last Item
- It's easy to see the length of a slice or range when only the stop position is given: `range(3)` and `my_list[:3]` both produce three items
- It's easy to compute the length of a slice or range when start and stop are given: just subtract `stop` - `start`
- It's easy to split a sequence in two parts at any index `x`, without overlapping: simply get `my_list[:x]` and `my_list[x:]`

### Slice Objects
- `s[a:b:c]` can be used to specify a stride or step c

### Multidimensional Slicing and Ellipsis
